use anchor_lang::{prelude::*, solana_program::hash::Hash};

use crate::{
    error::ErrorCode, merkle_helper::verify_helper, ConsensusResult, MetaMerkleLeaf,
    MetaMerkleProof, StakeMerkleLeaf,
};

#[derive(Accounts)]
#[instruction(meta_merkle_leaf: MetaMerkleLeaf, meta_merkle_proof: Vec<[u8; 32]>)]
pub struct VerifyMerkleProof<'info> {
    #[account(has_one = consensus_result)]
    pub meta_merkle_proof: Box<Account<'info, MetaMerkleProof>>,
    pub consensus_result: Box<Account<'info, ConsensusResult>>,
}

pub fn handler(
    ctx: Context<VerifyMerkleProof>,
    stake_merkle_proof: Option<Vec<[u8; 32]>>,
    stake_merkle_leaf: Option<StakeMerkleLeaf>,
) -> Result<()> {
    let meta_merkle_proof = &ctx.accounts.meta_merkle_proof;
    let consensus_result = &ctx.accounts.consensus_result;

    if stake_merkle_leaf.is_some() && stake_merkle_proof.is_some() {
        let proof_vec = stake_merkle_proof.unwrap();
        let stake_merkle_leaf_data = stake_merkle_leaf.unwrap();
        let leaf_content = &stake_merkle_leaf_data.hash().to_bytes();

        // Check that the root generated by the proof and StakeMerkleLeaf matches
        // root in MetaMerkleLeaf.
        verify_helper(
            leaf_content,
            proof_vec,
            Hash::from(meta_merkle_proof.meta_merkle_leaf.stake_merkle_root),
        )?;
    } else if stake_merkle_leaf.is_some() || stake_merkle_proof.is_some() {
        return Err(ErrorCode::InvalidMerkleInputs.into());
    }

    let leaf_content = &meta_merkle_proof.meta_merkle_leaf.hash().to_bytes();

    // Check that the root generated by the proof and MetaMerkleLeaf matches
    // root in ConsensusResult.
    verify_helper(
        leaf_content,
        meta_merkle_proof.meta_merkle_proof.clone(),
        consensus_result.ballot.meta_merkle_root.into(),
    )?;

    Ok(())
}
